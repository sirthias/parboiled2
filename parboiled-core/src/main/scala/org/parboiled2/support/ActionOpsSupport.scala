/*
 * Copyright (C) 2009-2013 Mathias Doenitz, Alexander Myltsev
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.parboiled2.support

import shapeless.ops.hlist.ReversePrepend
import shapeless._
import org.parboiled2.Rule

/*
 * The main ActionOps boilerplate is generated by a custom SBT sourceGenerator.
 * This file only contains support types.
 */

// we want to support the "short case class notation" `... ~> Foo`
// unfortunately the Tree for the function argument to the `apply` overloads above does *not* allow us to inspect the
// function type which is why we capture it separately with this helper type
sealed trait FCapture[T]
object FCapture {
  implicit def apply[T]: FCapture[T] = `n/a`
}

// Given C, I <: HList, L <: HList and R builds `Out <: Rule[_, _, _]` according to this logic:
//  if (R == Unit)
//    Rule[C, I, L]
//  else if (R <: HList)
//    Rule[C, I, L ::: R]
//  else if (R <: Rule[C, I2, O2])
//    Rule[C, TailSwitch[I2, L, I], TailSwitch[L, I2, O2]]
//  else
//    Rule[C, I, L ::: R :: HNil]
sealed trait Join[C, I <: HList, L <: HList, R] {
  type Out <: Rule[_, _, _]
}
object Join {
  implicit def join[C, I <: HList, L <: HList, R, Out0 <: Rule[_, _, _]](
    implicit x: Aux[C, I, L, R, HNil, Out0]): Join[C, I, L, R] { type Out = Out0 } = `n/a`

  sealed trait Aux[C, I <: HList, L <: HList, R, Acc <: HList, Out <: Rule[_, _, _]]
  object Aux extends Aux1 {
    // if R == Unit convert to HNil
    implicit def forUnit[C, I <: HList, L <: HList, Acc <: HList, Out <: Rule[_, _, _]](
      implicit x: Aux[C, I, L, HNil, Acc, Out]): Aux[C, I, L, Unit, Acc, Out] = `n/a`

    // if R <: HList and L non-empty move head of L to Acc
    implicit def iter2[C, I <: HList, H, T <: HList, R <: HList, Acc <: HList, Out <: Rule[_, _, _]](
      implicit x: Aux[C, I, T, R, H :: Acc, Out]): Aux[C, I, H :: T, R, Acc, Out] = `n/a`

    // if R <: HList and L empty set Out = reversePrepend Acc before R
    implicit def terminate[C, I <: HList, R <: HList, Acc <: HList, Out <: HList](
      implicit x: ReversePrepend.Aux[Acc, R, Out]): Aux[C, I, HNil, R, Acc, Rule[C, I, Out]] = `n/a`

    // if R <: Rule return tailswitches result
    implicit def terminateRule[C, I <: HList, L <: HList, I2 <: HList, O2 <: HList, In <: HList, Out <: HList, Ctx <: C](
      implicit i: TailSwitch.Aux[I2, I2, L, L, I, HNil, In],
      o: TailSwitch.Aux[L, L, I2, I2, O2, HNil, Out]): Aux[C, I, L, Rule[Ctx, I2, O2], HNil, Rule[Ctx, In, Out]] = `n/a`
  }

  abstract class Aux1 {
    // convert R to R :: HNil
    implicit def forAny[C, I <: HList, L <: HList, R, Out <: Rule[_, _, _]](
      implicit x: Aux[C, I, L, R :: HNil, HNil, Out]): Aux[C, I, L, R, HNil, Out] = `n/a`
  }
}